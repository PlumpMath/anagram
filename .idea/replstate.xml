<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1400217413747">{:repl-history {:ide [], :local [&quot;(count ts)&quot; &quot;(rest ts)&quot; &quot;(first ts)&quot; &quot;(= (first ts) (first (first (first ts))))&quot; &quot;((first (first (first ts))))&quot; &quot;(first (first ts))&quot; &quot;(next ts)&quot; &quot; (next (next ts))&quot; &quot; (first (next (next ts)))&quot; &quot; (next (next (next ts)))&quot; &quot; (first (next (next (next ts))))&quot; &quot; (= (first ts) (first (next (next (next ts)))))&quot; &quot;(def w \&quot;foo\&quot;)&quot; &quot;(def words [\&quot;foo\&quot; \&quot;foostein\&quot; \&quot;bar\&quot;])&quot; &quot;(some (partial = w) words)&quot; &quot;(some #(\\b) \&quot;bee\&quot;)&quot; &quot;(some #(\\b) [\&quot;bee\&quot;])&quot; &quot;(some #( '(\\b) ) [\&quot;bee\&quot;])&quot; &quot;(some #( '(\\b) ) '(\\b \\e \\e))&quot; &quot;(some #( '(\\b) ) '(\\b \\e \\e) )&quot; &quot;(type '(\\b \\e \\e))&quot; &quot;ts&quot; &quot;(type ts)&quot; &quot;(some #(\&quot;b\&quot;) \&quot;bee\&quot; )&quot; &quot;(contains? ts \&quot;t\&quot;)&quot; &quot;(vec ts)&quot; &quot;(get \&quot;t\&quot; (vec ts) )&quot; &quot;(get \&quot;\\t\&quot; (vec ts) )&quot; &quot;(contains? \&quot;\\t\&quot; (vec ts) )&quot; &quot;(contains? #{\\t} (vec ts) )&quot; &quot;(contains? #{\&quot;\\t\&quot;} (vec ts) )&quot; &quot;(contains? #{\&quot;\\t\&quot;} (ts) )&quot; &quot;(contains? #{\&quot;\\t\&quot;} ts )&quot; &quot;(contains? #{\\t} ts )&quot; &quot;(contains? #{ 1 } [1 2 3] )&quot; &quot;(use 'clojure.data)&quot; &quot;(diff \&quot;foo\&quot; \&quot;foostein\&quot;)&quot; &quot;(diff (seq \&quot;foo\&quot;) (seq \&quot;foostein\&quot;))&quot; &quot;(diff (seq \&quot;foo\&quot;) (seq \&quot;stfeiono\&quot;))&quot; &quot;(def one \&quot;foo\&quot;)&quot; &quot;(def dos \&quot;fdovo\&quot;)&quot; &quot;(diff one dos)&quot; &quot;(diff (seq one) (seq dos))&quot; &quot;(frequencies one\n             )&quot; &quot;(def fone (frequencies one))&quot; &quot;fone&quot; &quot;(def fdos (frequencies dos))&quot; &quot;fdos&quot; &quot;(diff fone fdos)&quot; &quot;(def res (diff fone fdos))&quot; &quot;(= fone res)&quot; &quot;(= fone (last res))&quot; &quot;(ns anagram.core\n  (:require [clojure.string :as str]\n            [clojure.data :as d]))&quot; &quot;(defn contains-word?\n  \&quot;Predicate to decide if the letters of one string1 are containted in string2 another\&quot;\n  [string1 string2]\n  (let [s1 (frequencies string1)\n        s2 (frequencies string2)\n        diffs (d/diff s1 s2 )]\n    (= s1 (last diffs))))&quot; &quot;(ns anagram.core\n  (:require [clojure.string :as str]\n            [clojure.data :as data]))&quot; &quot;(defn contains-word?\n  \&quot;Predicate to decide if the letters of one string1 are containted in string2 another\&quot;\n  [string1 string2]\n  (let [s1 (frequencies string1)\n        s2 (frequencies string2)\n        diffs (data/diff s1 s2 )]\n    (= s1 (last diffs))))&quot; &quot;(defn contains-word?\n  \&quot;Predicate to decide if the letters of one string1 are containted in string2 another\&quot;\n  [string1 string2]\n  (let [s1 (frequencies string1)\n        s2 (frequencies string2)\n        diffs (data/diff s1 s2 )]\n    (print s1)\n    (print s2)\n    (print diffs)\n    (= s1 (last diffs))))&quot; &quot;(defn contains-word?\n  \&quot;Predicate to decide if the letters of one string1 are containted in string2 another\&quot;\n  [string1 string2]\n  (let [s1 (frequencies string1)\n        s2 (frequencies string2)\n        diffs (data/diff s1 s2 )]\n    (print s1 \&quot;\\n\&quot;)\n    (print s2)\n    (print diffs)\n    (= s1 (last diffs))))&quot; &quot;(defn contains-word?\n  \&quot;Predicate to decide if the letters of one string1 are containted in string2 another\&quot;\n  [string1 string2]\n  (let [s1 (frequencies string1)\n        s2 (frequencies string2)\n        diffs (data/diff s1 s2 )]\n    (print s1 \&quot;\\n\&quot;)\n    (print s2 \&quot;\\n\&quot;)\n    (print diffs)\n    (= s1 (last diffs))))&quot; &quot;(contains-word? \&quot;foo\&quot; \&quot;ffogo\&quot;)&quot; &quot;(def map1 {1 44 2 33})\n(def map2 {1 55 2 33})&quot; &quot;(merge-with not= map1 map2\n            )&quot; &quot;(doc merge-with)&quot; &quot;(apply require clojure.main/repl-requires)&quot; &quot;(doc merge-with\n     )&quot; &quot;(def A (frequencies \&quot;scarf\&quot;))&quot; &quot;(def B (frequencies \&quot;shoes\&quot;))&quot; &quot;(sort A)&quot; &quot;(sort B)&quot; &quot;(doc sort)&quot; &quot;(get A \\s)&quot; &quot;(def A (frequencies \&quot;foo\&quot;))&quot; &quot;(def B (frequencies \&quot;shofroeo\&quot;))&quot; &quot;A&quot; &quot;(first A)&quot; &quot;(get A \\o)&quot; &quot;(get A \\q)&quot; &quot;(defn foo\n  \&quot;given a tuple, finds that tuple in a map\&quot;\n  [t m]\n  (let [tkey (first t)\n        tval (last t)\n        mkey (get m tkey)]\n    (&lt;= tval (last mkey))))&quot; &quot;(get B \\f )&quot; &quot;(first [\\f 1])&quot; &quot;(last [\\f 1])&quot; &quot;(get m (first [\\f 1]))&quot; &quot;(get B (first [\\f 1]))&quot; &quot;(&lt;= (last [\\f 1]) (get B (first [\\f 1])) )&quot; &quot;(defn foo\n  \&quot;given a tuple, finds that tuple in a map\&quot;\n  [t m]\n  (let [tkey (first t)\n        tval (last t)\n        mkey (get m tkey)\n        mval (last mkey)]\n    (&lt;= tval mval)))&quot; &quot;(foo [\\f 1] B)&quot; &quot;b&quot; &quot;B&quot; &quot;(foo '(\\f 1) B)&quot; &quot;tup&quot; &quot;(foo tup B)&quot; &quot;(type tup)&quot; &quot;(type B)&quot; &quot;m &quot; &quot;(def m {\\f 1 \\g 2 \\c 3})&quot; &quot;(def tup [\\f 1])&quot; &quot;(def m {\\f 1, \\h 2, \\r 3})&quot; &quot;(defn foo\n  \&quot;given a tuple, finds that tuple in a map\&quot;\n  [t m]\n  (let [tkey (first t)\n        tval (last t)\n        mkey (get m tkey)\n        mval (last mkey)]\n    (println tkey)\n    (println tval)\n    (println mkey)\n    (println mval)\n    (&lt;= tval mval)))&quot; &quot;m&quot; &quot;(type m)&quot; &quot;(foo tup m)&quot;], :remote []}}</component>
</project>

